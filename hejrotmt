input {
  beats {
    port => 5044
  }
}

filter {
  # -------------------------
  # Parse the log line
  # -------------------------
  grok {
    match => {
      "message" => [
        # Start MQ
        '%{DATE:log_date}\|%{TIME:log_time}\|.*Found MQ Message ID \[Hex\] = \[%{DATA:hex_id}\]',
        # End Save trade
        '%{DATE:log_date}\|%{TIME:log_time}\|.*Save trade %{DATA:trade_id} complete',
        # Failed MQ
        '%{DATE:log_date}\|%{TIME:log_time}\|.*Failed to Find MQ Message ID \[Hex\] = \[%{DATA:hex_id}\]',
        # Pretrade
        '%{DATE:log_date}\|%{TIME:log_time}\|.*Saved Focus trade %{DATA:trade_id} from pretrade %{DATA:pretrade_id}',
        # QProxy
        '%{DATE:log_date}\|%{TIME:log_time}\|.*Received RequestManagerCall response from QProxy for Requestid %{DATA:req_id} in %{NUMBER:duration:float} s',
        # PV01
        '%{DATE:log_date}\|%{TIME:log_time}\|.*Received PV01 response from QProxy for %{DATA:value} with Request Id %{DATA:req_id} in %{NUMBER:duration:float} s'
      ]
    }
  }

  # -------------------------
  # Convert timestamp
  # -------------------------
  mutate {
    add_field => { "log_ts" => "%{log_date} %{log_time}" }
  }

  date {
    match => ["log_ts", "yyyy-MM-dd HH:mm:ss.SSS"]
    timezone => "Asia/Kolkata"
  }

  # -------------------------
  # Identify start / end / pretrade / failed / QProxy / PV01
  # -------------------------
  mutate {
    add_field => { "is_start" => "false" }
    add_field => { "is_end" => "false" }
    add_field => { "is_pretrade" => "false" }
    add_field => { "is_failed" => "false" }
    add_field => { "is_qproxy" => "false" }
    add_field => { "is_pv01" => "false" }
  }

  if "Found MQ" in [message] {
    mutate { replace => { "is_start" => "true" } }
  }

  if "Save trade" in [message] {
    mutate { replace => { "is_end" => "true" } }
  }

  if "Saved Focus trade" in [message] {
    mutate { replace => { "is_pretrade" => "true" } }
  }

  if "Failed to Find MQ" in [message] {
    mutate { replace => { "is_failed" => "true" } }
  }

  if "Received RequestManagerCall response from QProxy" in [message] {
    mutate { replace => { "is_qproxy" => "true" } }
  }

  if "Received PV01 response from QProxy" in [message] {
    mutate { replace => { "is_pv01" => "true" } }
  }

  # -------------------------
  # Aggregate by trade_id
  # -------------------------
  aggregate {
    task_id => "%{trade_id}"
    code => "
      map['trade_id'] ||= event.get('trade_id')
      map['start'] ||= event.get('log_ts') if event.get('is_start') == 'true'
      map['end'] ||= event.get('log_ts') if event.get('is_end') == 'true'
      map['hex_id'] ||= event.get('hex_id') if event.get('is_start') == 'true'

      # QProxy
      map['qproxy'] ||= []
      if event.get('is_qproxy') == 'true'
        map['qproxy'] << { 'req_id' => event.get('req_id'), 'duration' => event.get('duration') }
      end

      # PV01
      map['pv01'] ||= []
      if event.get('is_pv01') == 'true'
        map['pv01'] << { 'req_id' => event.get('req_id'), 'value' => event.get('value'), 'duration' => event.get('duration') }
      end
    "
    end_of_task => "%{is_end}" == "true"
    push_map_as_event_on_timeout => true
    timeout => 300
    timeout_tags => ['_aggregatetimeout']

    timeout_code => "
      if map['start'] && map['end']
        start_ts = Time.parse(map['start'])
        end_ts = Time.parse(map['end'])
        event.set('duration', (end_ts - start_ts).to_f)
      end
      event.set('qproxy', map['qproxy'])
      event.set('pv01', map['pv01'])
    "
  }
}

output {
  elasticsearch {
    hosts => ["http://localhost:9200"]
    index => "bp-logs-%{+YYYY.MM.dd}"
    user => "elastic"
    password => "your_password"
  }

  stdout { codec => rubydebug }
}